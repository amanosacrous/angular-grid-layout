/**
 * IMPORTANT:
 * This utils are taken from the project: https://github.com/STRML/react-grid-layout.
 * The code should be as less modified as possible for easy maintenance.
 */
import { getAllCollisions, getFirstCollision, sortLayoutItems } from "./react-grid-layout.utils";
const DEBUG = false;
// Disable lint since we don't want to modify this code
/* eslint-disable */
/**
 * Move an element. Responsible for doing cascading movements of other elements.
 *
 * @param  {Array}      layout            Full layout to modify.
 * @param  {LayoutItem} l                 element to move.
 * @param  {Number}     [x]               X position in grid units.
 * @param  {Number}     [y]               Y position in grid units.
 */
export function moveElements(layout, items, isUserAction, preventCollision, compactType, cols) {
    // Short-circuit if nothing to do.
    if (items.every((item) => item.l.y === item.y && item.l.x === item.x)) {
        return layout;
    }
    const oldX = items[0].l.x;
    const oldY = items[0].l.y;
    const oldCoord = {};
    items.forEach((item) => {
        oldCoord[item.l.id] = {
            x: item.l.x,
            y: item.l.y
        };
        if (typeof item.x === 'number') {
            item.l.x = item.x;
        }
        if (typeof item.y === 'number') {
            item.l.y = item.y;
        }
        item.l.moved = true;
    });
    let sorted = sortLayoutItems(layout, compactType);
    // If this collides with anything, move it.
    // When doing this comparison, we have to sort the items we compare with
    // to ensure, in the case of multiple collisions, that we're getting the
    // nearest collision.
    const movingUp = compactType === 'vertical' && typeof items[0].y === 'number'
        ? oldY >= items[0].y
        : compactType === 'horizontal' && typeof items[0].x === 'number'
            ? oldX >= items[0].x
            : false;
    if (movingUp) {
        sorted = sorted.reverse();
    }
    items.forEach((item) => {
        const collisions = getAllCollisions(sorted, item.l);
        if (preventCollision && collisions.length) {
            item.l.x = oldCoord[item.l.id].x;
            item.l.y = oldCoord[item.l.id].y;
            item.l.moved = false;
        }
        else {
            // Move each item that collides away from this element.
            for (let i = 0, len = collisions.length; i < len; i++) {
                const collision = collisions[i];
                logMulti(`Resolving collision between ${items}] and ${collision.id} at [${collision.x},${collision.y}]`);
                // Short circuit so we can't infinite loop
                if (collision.moved) {
                    continue;
                }
                // Don't move static items - we have to move *this* element away
                if (collision.static) {
                    layout = moveElementsAwayFromCollision(layout, collision, item.l, isUserAction, compactType, cols);
                }
                else {
                    layout = moveElementsAwayFromCollision(layout, item.l, collision, isUserAction, compactType, cols);
                }
            }
        }
    });
    return layout;
}
export function moveElementsAwayFromCollision(layout, collidesWith, itemToMove, isUserAction, compactType, cols) {
    const compactH = compactType === 'horizontal';
    // Compact vertically if not set to horizontal
    const compactV = compactType !== 'horizontal';
    const preventCollision = collidesWith.static; // we're already colliding (not for static items)
    // If there is enough space above the collision to put this element, move it there.
    // We only do this on the main collision as this can get funky in cascades and cause
    // unwanted swapping behavior.
    if (isUserAction) {
        // Reset isUserAction flag because we're not in the main collision anymore.
        isUserAction = false;
        // Make a mock item so we don't modify the item here, only modify in moveElement.
        const fakeItem = {
            x: compactH
                ? Math.max(collidesWith.x - itemToMove.w, 0)
                : itemToMove.x,
            y: compactV
                ? Math.max(collidesWith.y - itemToMove.h, 0)
                : itemToMove.y,
            w: itemToMove.w,
            h: itemToMove.h,
            id: '-1',
        };
        // No collision? If so, we can go up there; otherwise, we'll end up moving down as normal
        if (!getFirstCollision(layout, fakeItem)) {
            logMulti(`Doing reverse collision on ${itemToMove.id} up to [${fakeItem.x},${fakeItem.y}].`);
            return moveElements(layout, [{
                    l: itemToMove,
                    x: compactH ? fakeItem.x : undefined,
                    y: compactV ? fakeItem.y : undefined,
                }], isUserAction, preventCollision, compactType, cols);
        }
    }
    return moveElements(layout, [{
            l: itemToMove,
            x: compactH ? itemToMove.x + 1 : undefined,
            y: compactV ? itemToMove.y + 1 : undefined,
        }], isUserAction, preventCollision, compactType, cols);
}
function logMulti(...args) {
    if (!DEBUG) {
        return;
    }
    // eslint-disable-next-line no-console
    console.log(...args);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVhY3QtZ3JpZC1sYXlvdXQtbXVsdGlwbGUudXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9hbmd1bGFyLWdyaWQtbGF5b3V0L3NyYy9saWIvdXRpbHMvcmVhY3QtZ3JpZC1sYXlvdXQtbXVsdGlwbGUudXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7R0FJRztBQUVILE9BQU8sRUFBZSxnQkFBZ0IsRUFBRSxpQkFBaUIsRUFBc0IsZUFBZSxFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFFbEksTUFBTSxLQUFLLEdBQUcsS0FBSyxDQUFDO0FBRXBCLHVEQUF1RDtBQUN2RCxvQkFBb0I7QUFFcEI7Ozs7Ozs7R0FPRztBQUNILE1BQU0sVUFBVSxZQUFZLENBQ3hCLE1BQWMsRUFDZCxLQUlHLEVBQ0gsWUFBd0MsRUFDeEMsZ0JBQTRDLEVBQzVDLFdBQXdCLEVBQ3hCLElBQVk7SUFFWixrQ0FBa0M7SUFDbEMsSUFBRyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxFQUFDLEVBQUUsQ0FBQSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxJQUFJLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBQztRQUMvRCxPQUFPLE1BQU0sQ0FBQztLQUNqQjtJQUVELE1BQU0sSUFBSSxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzFCLE1BQU0sSUFBSSxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzFCLE1BQU0sUUFBUSxHQUFHLEVBQUUsQ0FBQTtJQUVuQixLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxFQUFDLEVBQUU7UUFDbEIsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFD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RUFBRSxRQUFRLENBQUMsRUFBRTtZQUN0QyxRQUFRLENBQ0osOEJBQThCLFVBQVUsQ0FBQyxFQUFFLFdBQ3ZDLFFBQVEsQ0FBQyxDQUNiLElBQUksUUFBUSxDQUFDLENBQUMsSUFBSSxDQUNyQixDQUFDO1lBQ0YsT0FBTyxZQUFZLENBQ2YsTUFBTSxFQUNOLENBQUM7b0JBQ0csQ0FBQyxFQUFFLFVBQVU7b0JBQ2IsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUztvQkFDcEMsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUztpQkFDdkMsQ0FBQyxFQUNGLFlBQVksRUFDWixnQkFBZ0IsRUFDaEIsV0FBVyxFQUNYLElBQUksQ0FDUCxDQUFDO1NBQ0w7S0FDSjtJQUVELE9BQU8sWUFBWSxDQUNmLE1BQU0sRUFDTixDQUFDO1lBQ0csQ0FBQyxFQUFFLFVBQVU7WUFDYixDQUFDLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxHQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUztZQUN4QyxDQUFDLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxHQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUztTQUMzQyxDQUFDLEVBQ0YsWUFBWSxFQUNaLGdCQUFnQixFQUNoQixXQUFXLEVBQ1gsSUFBSSxDQUNQLENBQUM7QUFDTixDQUFDO0FBRUQsU0FBUyxRQUFRLENBQUMsR0FBRyxJQUFJO0lBQ3JCLElBQUksQ0FBQyxLQUFLLEVBQUU7UUFDUixPQUFPO0tBQ1Y7SUFDRCxzQ0FBc0M7SUFDdEMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDO0FBQ3pCLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogSU1QT1JUQU5UOlxyXG4gKiBUaGlzIHV0aWxzIGFyZSB0YWtlbiBmcm9tIHRoZSBwcm9qZWN0OiBodHRwczovL2dpdGh1Yi5jb20vU1RSTUwvcmVhY3QtZ3JpZC1sYXlvdXQuXHJcbiAqIFRoZSBjb2RlIHNob3VsZCBiZSBhcyBsZXNzIG1vZGlmaWVkIGFzIHBvc3NpYmxlIGZvciBlYXN5IG1haW50ZW5hbmNlLlxyXG4gKi9cclxuXHJcbmltcG9ydCB7IENvbXBhY3RUeXBlLCBnZXRBbGxDb2xsaXNpb25zLCBnZXRGaXJzdENvbGxpc2lvbiwgTGF5b3V0LCBMYXlvdXRJdGVtLCBzb3J0TGF5b3V0SXRlbXMgfSBmcm9tIFwiLi9yZWFjdC1ncmlkLWxheW91dC51dGlsc1wiO1xyXG5cclxuY29uc3QgREVCVUcgPSBmYWxzZTtcclxuXHJcbi8vIERpc2FibGUgbGludCBzaW5jZSB3ZSBkb24ndCB3YW50IHRvIG1vZGlmeSB0aGlzIGNvZGVcclxuLyogZXNsaW50LWRpc2FibGUgKi9cclxuXHJcbi8qKlxyXG4gKiBNb3ZlIGFuIGVsZW1lbnQuIFJlc3BvbnNpYmxlIGZvciBkb2luZyBjYXNjYWRpbmcgbW92ZW1lbnRzIG9mIG90aGVyIGVsZW1lbnRzLlxyXG4gKlxyXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICBsYXlvdXQgICAgICAgICAgICBGdWxsIGxheW91dCB0byBtb2RpZnkuXHJcbiAqIEBwYXJhbSAge0xheW91dEl0ZW19IGwgICAgICAgICAgICAgICAgIGVsZW1lbnQgdG8gbW92ZS5cclxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgW3hdICAgICAgICAgICAgICAgWCBwb3NpdGlvbiBpbiBncmlkIHVuaXRzLlxyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICBbeV0gICAgICAgICAgICAgICBZIHBvc2l0aW9uIGluIGdyaWQgdW5pdHMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbW92ZUVsZW1lbnRzKFxyXG4gICAgbGF5b3V0OiBMYXlvdXQsXHJcbiAgICBpdGVtczoge1xyXG4gICAgICAgIGw6IExheW91dEl0ZW0sXHJcbiAgICAgICAgeDogbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZCxcclxuICAgICAgICB5OiBudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkXHJcbiAgICB9W10sXHJcbiAgICBpc1VzZXJBY3Rpb246IGJvb2xlYW4gfCBudWxsIHwgdW5kZWZpbmVkLFxyXG4gICAgcHJldmVudENvbGxpc2lvbjogYm9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWQsXHJcbiAgICBjb21wYWN0VHlwZTogQ29tcGFjdFR5cGUsXHJcbiAgICBjb2xzOiBudW1iZXJcclxuKTogTGF5b3V0IHtcclxuICAgIC8vIFNob3J0LWNpcmN1aXQgaWYgbm90aGluZyB0byBkby5cclxuICAgIGlmKGl0ZW1zLmV2ZXJ5KChpdGVtKT0+aXRlbS5sLnkgPT09IGl0ZW0ueSAmJiBpdGVtLmwueCA9PT0gaXRlbS54KSl7XHJcbiAgICAgICAgcmV0dXJuIGxheW91dDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBvbGRYID0gaXRlbXNbMF0ubC54O1xyXG4gICAgY29uc3Qgb2xkWSA9IGl0ZW1zWzBdLmwueTtcclxuICAgIGNvbnN0IG9sZENvb3JkID0ge31cclxuXHJcbiAgICBpdGVtcy5mb3JFYWNoKChpdGVtKT0+e1xyXG4gICAgICAgIG9sZENvb3JkW2l0ZW0ubC5pZF09e1xyXG4gICAgICAgICAgICB4OiBpdGVtLmwueCxcclxuICAgICAgICAgICAgeTogaXRlbS5sLnlcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtLnggPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIGl0ZW0ubC54ID0gaXRlbS54O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIGl0ZW0ueSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICBpdGVtLmwueSA9IGl0ZW0ueTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaXRlbS5sLm1vdmVkID0gdHJ1ZTtcclxuICAgIH0pXHJcblxyXG4gICAgbGV0IHNvcnRlZCA9IHNvcnRMYXlvdXRJdGVtcyhsYXlvdXQsIGNvbXBhY3RUeXBlKTtcclxuICAgIC8vIElmIHRoaXMgY29sbGlkZXMgd2l0aCBhbnl0aGluZywgbW92ZSBpdC5cclxuICAgIC8vIFdoZW4gZG9pbmcgdGhpcyBjb21wYXJpc29uLCB3ZSBoYXZlIHRvIHNvcnQgdGhlIGl0ZW1zIHdlIGNvbXBhcmUgd2l0aFxyXG4gICAgLy8gdG8gZW5zdXJlLCBpbiB0aGUgY2FzZSBvZiBtdWx0aXBsZSBjb2xsaXNpb25zLCB0aGF0IHdlJ3JlIGdldHRpbmcgdGhlXHJcbiAgICAvLyBuZWFyZXN0IGNvbGxpc2lvbi5cclxuICAgIGNvbnN0IG1vdmluZ1VwID1cclxuICAgICAgICBjb21wYWN0VHlwZSA9PT0gJ3ZlcnRpY2FsJyAmJiB0eXBlb2YgaXRlbXNbMF0ueSA9PT0gJ251bWJlcidcclxuICAgICAgICAgICAgPyBvbGRZID49IGl0ZW1zWzBdLnlcclxuICAgICAgICAgICAgOiBjb21wYWN0VHlwZSA9PT0gJ2hvcml6b250YWwnICYmIHR5cGVvZiBpdGVtc1swXS54ID09PSAnbnVtYmVyJ1xyXG4gICAgICAgICAgICAgICAgPyBvbGRYID49IGl0ZW1zWzBdLnhcclxuICAgICAgICAgICAgICAgIDogZmFsc2U7XHJcbiAgICBpZiAobW92aW5nVXApIHtcclxuICAgICAgICBzb3J0ZWQgPSBzb3J0ZWQucmV2ZXJzZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGl0ZW1zLmZvckVhY2goKGl0ZW0pPT57XHJcbiAgICAgICAgY29uc3QgY29sbGlzaW9uczogTGF5b3V0SXRlbVtdID0gZ2V0QWxsQ29sbGlzaW9ucyhzb3J0ZWQsIGl0ZW0ubCk7XHJcbiAgICAgICAgaWYgKHByZXZlbnRDb2xsaXNpb24gJiYgY29sbGlzaW9ucy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgaXRlbS5sLnggPSBvbGRDb29yZFtpdGVtLmwuaWRdLng7XHJcbiAgICAgICAgICAgIGl0ZW0ubC55ID0gb2xkQ29vcmRbaXRlbS5sLmlkXS55O1xyXG4gICAgICAgICAgICBpdGVtLmwubW92ZWQgPSBmYWxzZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBNb3ZlIGVhY2ggaXRlbSB0aGF0IGNvbGxpZGVzIGF3YXkgZnJvbSB0aGlzIGVsZW1lbnQuXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBjb2xsaXNpb25zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xsaXNpb24gPSBjb2xsaXNpb25zW2ldO1xyXG4gICAgICAgICAgICAgICAgbG9nTXVsdGkoXHJcbiAgICAgICAgICAgICAgICAgICAgYFJlc29sdmluZyBjb2xsaXNpb24gYmV0d2VlbiAke2l0ZW1zfV0gYW5kICR7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxpc2lvbi5pZFxyXG4gICAgICAgICAgICAgICAgICAgIH0gYXQgWyR7Y29sbGlzaW9uLnh9LCR7Y29sbGlzaW9uLnl9XWAsXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgLy8gU2hvcnQgY2lyY3VpdCBzbyB3ZSBjYW4ndCBpbmZpbml0ZSBsb29wXHJcbiAgICAgICAgICAgICAgICBpZiAoY29sbGlzaW9uLm1vdmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBtb3ZlIHN0YXRpYyBpdGVtcyAtIHdlIGhhdmUgdG8gbW92ZSAqdGhpcyogZWxlbWVudCBhd2F5XHJcbiAgICAgICAgICAgICAgICBpZiAoY29sbGlzaW9uLnN0YXRpYykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxheW91dCA9IG1vdmVFbGVtZW50c0F3YXlGcm9tQ29sbGlzaW9uKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxpc2lvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5sLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1VzZXJBY3Rpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBhY3RUeXBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xzXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0ID0gbW92ZUVsZW1lbnRzQXdheUZyb21Db2xsaXNpb24oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5sLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsaXNpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzVXNlckFjdGlvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGFjdFR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHNcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIGxheW91dDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIG1vdmVFbGVtZW50c0F3YXlGcm9tQ29sbGlzaW9uKFxyXG4gICAgbGF5b3V0OiBMYXlvdXQsXHJcbiAgICBjb2xsaWRlc1dpdGg6IExheW91dEl0ZW0sXHJcbiAgICBpdGVtVG9Nb3ZlOiBMYXlvdXRJdGVtLFxyXG4gICAgaXNVc2VyQWN0aW9uOiBib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZCxcclxuICAgIGNvbXBhY3RUeXBlOiBDb21wYWN0VHlwZSxcclxuICAgIGNvbHM6IG51bWJlcixcclxuKTogTGF5b3V0IHtcclxuICAgIGNvbnN0IGNvbXBhY3RIID0gY29tcGFjdFR5cGUgPT09ICdob3Jpem9udGFsJztcclxuICAgIC8vIENvbXBhY3QgdmVydGljYWxseSBpZiBub3Qgc2V0IHRvIGhvcml6b250YWxcclxuICAgIGNvbnN0IGNvbXBhY3RWID0gY29tcGFjdFR5cGUgIT09ICdob3Jpem9udGFsJztcclxuICAgIGNvbnN0IHByZXZlbnRDb2xsaXNpb24gPSBjb2xsaWRlc1dpdGguc3RhdGljOyAvLyB3ZSdyZSBhbHJlYWR5IGNvbGxpZGluZyAobm90IGZvciBzdGF0aWMgaXRlbXMpXHJcblxyXG4gICAgLy8gSWYgdGhlcmUgaXMgZW5vdWdoIHNwYWNlIGFib3ZlIHRoZSBjb2xsaXNpb24gdG8gcHV0IHRoaXMgZWxlbWVudCwgbW92ZSBpdCB0aGVyZS5cclxuICAgIC8vIFdlIG9ubHkgZG8gdGhpcyBvbiB0aGUgbWFpbiBjb2xsaXNpb24gYXMgdGhpcyBjYW4gZ2V0IGZ1bmt5IGluIGNhc2NhZGVzIGFuZCBjYXVzZVxyXG4gICAgLy8gdW53YW50ZWQgc3dhcHBpbmcgYmVoYXZpb3IuXHJcbiAgICBpZiAoaXNVc2VyQWN0aW9uKSB7XHJcbiAgICAgICAgLy8gUmVzZXQgaXNVc2VyQWN0aW9uIGZsYWcgYmVjYXVzZSB3ZSdyZSBub3QgaW4gdGhlIG1haW4gY29sbGlzaW9uIGFueW1vcmUuXHJcbiAgICAgICAgaXNVc2VyQWN0aW9uID0gZmFsc2U7XHJcblxyXG4gICAgICAgIC8vIE1ha2UgYSBtb2NrIGl0ZW0gc28gd2UgZG9uJ3QgbW9kaWZ5IHRoZSBpdGVtIGhlcmUsIG9ubHkgbW9kaWZ5IGluIG1vdmVFbGVtZW50LlxyXG4gICAgICAgIGNvbnN0IGZha2VJdGVtOiBMYXlvdXRJdGVtID0ge1xyXG4gICAgICAgICAgICB4OiBjb21wYWN0SFxyXG4gICAgICAgICAgICAgICAgPyBNYXRoLm1heChjb2xsaWRlc1dpdGgueCAtIGl0ZW1Ub01vdmUudywgMClcclxuICAgICAgICAgICAgICAgIDogaXRlbVRvTW92ZS54LFxyXG4gICAgICAgICAgICB5OiBjb21wYWN0VlxyXG4gICAgICAgICAgICAgICAgPyBNYXRoLm1heChjb2xsaWRlc1dpdGgueSAtIGl0ZW1Ub01vdmUuaCwgMClcclxuICAgICAgICAgICAgICAgIDogaXRlbVRvTW92ZS55LFxyXG4gICAgICAgICAgICB3OiBpdGVtVG9Nb3ZlLncsXHJcbiAgICAgICAgICAgIGg6IGl0ZW1Ub01vdmUuaCxcclxuICAgICAgICAgICAgaWQ6ICctMScsXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gTm8gY29sbGlzaW9uPyBJZiBzbywgd2UgY2FuIGdvIHVwIHRoZXJlOyBvdGhlcndpc2UsIHdlJ2xsIGVuZCB1cCBtb3ZpbmcgZG93biBhcyBub3JtYWxcclxuICAgICAgICBpZiAoIWdldEZpcnN0Q29sbGlzaW9uKGxheW91dCwgZmFrZUl0ZW0pKSB7XHJcbiAgICAgICAgICAgIGxvZ011bHRpKFxyXG4gICAgICAgICAgICAgICAgYERvaW5nIHJldmVyc2UgY29sbGlzaW9uIG9uICR7aXRlbVRvTW92ZS5pZH0gdXAgdG8gWyR7XHJcbiAgICAgICAgICAgICAgICAgICAgZmFrZUl0ZW0ueFxyXG4gICAgICAgICAgICAgICAgfSwke2Zha2VJdGVtLnl9XS5gLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICByZXR1cm4gbW92ZUVsZW1lbnRzKFxyXG4gICAgICAgICAgICAgICAgbGF5b3V0LFxyXG4gICAgICAgICAgICAgICAgW3tcclxuICAgICAgICAgICAgICAgICAgICBsOiBpdGVtVG9Nb3ZlLFxyXG4gICAgICAgICAgICAgICAgICAgIHg6IGNvbXBhY3RIID8gZmFrZUl0ZW0ueCA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgICAgICB5OiBjb21wYWN0ViA/IGZha2VJdGVtLnkgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICB9XSxcclxuICAgICAgICAgICAgICAgIGlzVXNlckFjdGlvbixcclxuICAgICAgICAgICAgICAgIHByZXZlbnRDb2xsaXNpb24sXHJcbiAgICAgICAgICAgICAgICBjb21wYWN0VHlwZSxcclxuICAgICAgICAgICAgICAgIGNvbHNcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG1vdmVFbGVtZW50cyhcclxuICAgICAgICBsYXlvdXQsXHJcbiAgICAgICAgW3tcclxuICAgICAgICAgICAgbDogaXRlbVRvTW92ZSxcclxuICAgICAgICAgICAgeDogY29tcGFjdEggPyBpdGVtVG9Nb3ZlLngrMSA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgeTogY29tcGFjdFYgPyBpdGVtVG9Nb3ZlLnkrMSA6IHVuZGVmaW5lZCxcclxuICAgICAgICB9XSxcclxuICAgICAgICBpc1VzZXJBY3Rpb24sXHJcbiAgICAgICAgcHJldmVudENvbGxpc2lvbixcclxuICAgICAgICBjb21wYWN0VHlwZSxcclxuICAgICAgICBjb2xzXHJcbiAgICApO1xyXG59XHJcblxyXG5mdW5jdGlvbiBsb2dNdWx0aSguLi5hcmdzKSB7XHJcbiAgICBpZiAoIURFQlVHKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcclxuICAgIGNvbnNvbGUubG9nKC4uLmFyZ3MpO1xyXG59XHJcblxyXG4iXX0=